/**
 * @file driver_uart.c
 * @brief UART driver implementation with DMA-based transmission (CORRECTED VERSION)
 *
 * Architecture:
 * - RX: Interrupt-based, byte-by-byte reception with echo support
 * - TX: DMA-based transmission using a circular ring buffer
 *
 * Key Features:
 * - Zero-copy DMA transfers for efficient bulk transmission
 * - Atomic operations to prevent race conditions
 * - Memory barriers for multi-core/DMA synchronization
 * - Non-blocking echo functionality for terminal interaction
 *
 * Corrections Applied:
 * 1. Fixed race condition in uart_start_dma_from_ring() (atomic read of head/tail)
 * 2. Fixed TX callback to atomically check buffer state before releasing DMA token
 * 3. Removed blocking HAL_UART_Transmit() calls from RX interrupt
 * 4. Added memory barriers (__DMB) for CPU cache coherency
 * 5. Proper DMA restart logic in TX complete callback
 */

#include "i_comm.h"
#include "bsp_utils.h"   // Utility macros/types
#include "usart.h"       // STM32 HAL UART handle
#include "driver_uart.h"
#include <string.h>

/* -------------------------------------------------------------------------- */
/*                         Configuration Constants                            */
/* -------------------------------------------------------------------------- */
#define RX_BUFFER_SIZE      64      /**< Maximum line length for RX */
#define UART_TX_RING_SIZE   4096    /**< Circular buffer size for TX */

/* -------------------------------------------------------------------------- */
/*                         Internal State Variables                           */
/* -------------------------------------------------------------------------- */

/** Transmission complete flag (true = all data sent and buffer empty). */
static volatile bool tx_done = true;

/** Reception complete flag (true = one complete line is ready). */
static volatile bool rx_done = false;

/** Reception buffer (stores one line at a time). */
static uint8_t rx_buffer[RX_BUFFER_SIZE];

/** Current write index in rx_buffer. */
static volatile uint16_t rx_index = 0;

/** Single-byte buffer for interrupt-driven byte reception. */
static uint8_t rx_byte;

/** Alias to USART handle generated by CubeMX. */
UART_HandleTypeDef* UARTxA = &huart2;

/* -------------------------------------------------------------------------- */
/*                         Circular Ring Buffer for TX                        */
/* -------------------------------------------------------------------------- */

/**
 * @brief Ring buffer structure for DMA transmission.
 * 
 * Thread Safety:
 * - 'head' is modified by uart_send() and protected by __disable_irq()
 * - 'tail' is modified by HAL_UART_TxCpltCallback() and protected by __disable_irq()
 * - Reading both must be atomic to avoid race conditions
 */
typedef struct {
    uint8_t buffer[UART_TX_RING_SIZE];  /**< Data storage */
    volatile uint16_t head;              /**< Write index (producer) */
    volatile uint16_t tail;              /**< Read index (consumer) */
} ring_buffer_t;

static ring_buffer_t tx_ring;  /**< Global TX ring buffer instance */

/**
 * @brief Check if ring buffer is empty.
 * @note NOT thread-safe on its own - must be called within critical section.
 */
static inline bool tx_ring_is_empty(void) {
    return tx_ring.head == tx_ring.tail;
}

/**
 * @brief Check if ring buffer is full (one slot reserved to distinguish full/empty).
 * @note NOT thread-safe on its own - must be called within critical section.
 */
static inline bool tx_ring_is_full(void) {
    return ((tx_ring.head + 1) % UART_TX_RING_SIZE) == tx_ring.tail;
}

/**
 * @brief Push one byte into the TX ring buffer (thread-safe).
 * 
 * @param data Byte to push
 * @return true if successful, false if buffer is full
 * 
 * @note This function is atomic and can be called from any context.
 */
static bool tx_ring_push(uint8_t data) {
    __disable_irq(); 
    
    if (tx_ring_is_full()) {
        __enable_irq(); 
        return false; // Buffer overflow
    }
    
    tx_ring.buffer[tx_ring.head] = data;
    tx_ring.head = (tx_ring.head + 1) % UART_TX_RING_SIZE;
    
    __enable_irq();
    return true;
}

/* -------------------------------------------------------------------------- */
/*                         DMA Transmission State                             */
/* -------------------------------------------------------------------------- */

/** 
 * DMA busy token (true = DMA transfer in progress).
 * Acts as a mutex to prevent concurrent DMA operations.
 */
static volatile bool dma_tx_busy = false;

/** 
 * Length of current/last DMA transfer.
 * Used by TX callback to advance the tail pointer correctly.
 */
static volatile uint16_t last_dma_tx_len = 0;

/* -------------------------------------------------------------------------- */
/*                    DMA Transfer Initiation (Internal)                      */
/* -------------------------------------------------------------------------- */

/**
 * @brief Start a DMA transfer from the ring buffer (CORRECTED VERSION).
 *
 * This function attempts to start a DMA transfer for the largest contiguous
 * block available in the TX ring buffer.
 *
 * CRITICAL FIXES:
 * 1. All checks and calculations done in ONE critical section to prevent
 *    race conditions where head/tail change between read and use.
 * 2. Memory barriers (__DMB) ensure CPU cache coherency with DMA controller.
 * 3. DMA token (dma_tx_busy) is acquired atomically before starting transfer.
 *
 * @return true if DMA transfer successfully started, false otherwise
 *         (buffer empty, DMA already busy, or HAL error)
 */
static bool uart_start_dma_from_ring(void)
{
    uint16_t len = 0;
    uint8_t *ptr = NULL;

    /* ========== CRITICAL SECTION: Read state, calculate, acquire token ========== */
    __disable_irq();
    
    // Memory barrier: ensure all previous writes are visible
    __DMB();
    
    // Test 1: Is DMA already running?
    if (dma_tx_busy) {
        __enable_irq();
        return false;
    }
    
    // Test 2: Is buffer empty?
    uint16_t head = tx_ring.head;
    uint16_t tail = tx_ring.tail;
    
    if (head == tail) {
        __enable_irq();
        return false;
    }
    
    // Calculate contiguous block length
    // Note: We only send up to the end of the buffer to keep it simple.
    // If data wraps around, it will be sent in the next DMA transfer.
    if (head > tail) {
        // Case 1: [tail...head-1] is contiguous
        len = head - tail;
        ptr = &tx_ring.buffer[tail];
    } else { 
        // Case 2: [tail...end] is first contiguous chunk (wrap-around case)
        len = UART_TX_RING_SIZE - tail;
        ptr = &tx_ring.buffer[tail];
    }
    
    // Acquire DMA token (mutex)
    dma_tx_busy = true;
    last_dma_tx_len = len;
    tx_done = false;
    
    // Memory barrier: ensure dma_tx_busy=true is written before continuing
    __DMB();
    
    __enable_irq();
    /* ========================================================================== */

    // Start DMA transmission (outside critical section)
    if (HAL_UART_Transmit_DMA(UARTxA, ptr, len) != HAL_OK) {
        // DMA start failed: release token and restore state
        __disable_irq();
        dma_tx_busy = false;
        last_dma_tx_len = 0;
        
        // If buffer became empty, mark TX as ready
        if (tx_ring_is_empty()) {
            tx_done = true;
        }
        
        __DMB();
        __enable_irq();
        return false;
    }

    return true; // DMA successfully started
}

/* -------------------------------------------------------------------------- */
/*                    Interface Function Declarations                         */
/* -------------------------------------------------------------------------- */
static bool uart_init(void);
static comm_status_t uart_send(comm_node_t node, const uint8_t* data, uint16_t length);
static comm_status_t uart_receive(uint8_t* data, uint16_t length);
static bool uart_is_tx_ready(void);
static bool uart_rx_available(void);
static void uart_flush(void);

/* -------------------------------------------------------------------------- */
/*                    Interface Function Implementations                      */
/* -------------------------------------------------------------------------- */

/**
 * @brief Initialize UART peripheral.
 * 
 * Initializes hardware, clears buffers, and sends startup message.
 * Uses blocking transmission for initialization (before DMA setup).
 * 
 * @return true if successful, false if HAL init fails
 */
static bool uart_init(void)
{
    if (HAL_UART_Init(UARTxA) != HAL_OK)
        return false;

    // Initialize state variables
    tx_done = true;
    rx_done = false;
    rx_index = 0;
    tx_ring.head = 0;
    tx_ring.tail = 0;
    dma_tx_busy = false;
    last_dma_tx_len = 0;

    // Arm first byte reception
    HAL_UART_Receive_IT(UARTxA, &rx_byte, 1);

    // Clear any existing prompt on terminal (blocking is OK during init)
    const char bs_prompt[] = {0x08, ' ', 0x08, 0x08, ' ', 0x08};
    HAL_UART_Transmit(UARTxA, (uint8_t*)bs_prompt, sizeof(bs_prompt), HAL_MAX_DELAY);

    // Send startup message with ANSI color codes
    const char *sys_start = "\033[34mStarting the System... \r\n\033[0m";
    HAL_UART_Transmit(UARTxA, (uint8_t*)sys_start, strlen(sys_start), HAL_MAX_DELAY);

    // Display prompt
    const char prompt[] = "> ";
    HAL_UART_Transmit(UARTxA, (uint8_t*)prompt, sizeof(prompt)-1, HAL_MAX_DELAY);

    return true;
}

/**
 * @brief Send data via UART using DMA (non-blocking).
 *
 * This function:
 * 1. Pushes all data into the TX ring buffer (atomic push operations)
 * 2. Attempts to start DMA if idle
 * 3. Returns immediately without waiting for transmission
 *
 * @param node Unused (for interface compatibility)
 * @param data Pointer to data buffer
 * @param length Number of bytes to send
 * @return COMM_OK if data buffered successfully, COMM_ERROR if buffer full
 *
 * @note If DMA is busy, data is buffered and will be sent automatically
 *       when current transfer completes.
 */
static comm_status_t uart_send(comm_node_t node, const uint8_t* data, uint16_t length)
{
    UNUSED(node);

    if (data == NULL || length == 0)
        return COMM_ERROR;

    // Push all data into ring buffer
    // tx_ring_push() is atomic, so IRQs remain enabled here for better responsiveness
    for (uint16_t i = 0; i < length; i++) {
        if (!tx_ring_push(data[i])) {
            return COMM_ERROR; // Buffer overflow
        }
    }

    // Try to start DMA if it's not already running
    // If DMA is busy, the data will be sent when the current transfer completes
    (void)uart_start_dma_from_ring();

    return COMM_OK;
}

/**
 * @brief Retrieve a complete received line.
 *
 * Should only be called after rx_available() returns true.
 * Copies the line into user buffer and resets RX state.
 *
 * @param data User buffer to copy line into
 * @param length Maximum buffer size
 * @return COMM_OK if line copied, COMM_BUSY if no line ready, COMM_ERROR on invalid params
 */
static comm_status_t uart_receive(uint8_t* data, uint16_t length)
{
    if (data == NULL || length == 0)
        return COMM_ERROR;

    if (!rx_done)
        return COMM_BUSY;

    // Copy received line (limit to user buffer size)
    uint16_t copy_len = (length < rx_index) ? length : rx_index;
    memcpy(data, rx_buffer, copy_len);

    // Null-terminate if space available
    if (copy_len < length) {
        data[copy_len] = '\0';
    }

    // Reset RX state for next line
    rx_done = false;
    rx_index = 0;

    return COMM_OK;
}

/**
 * @brief Check if all TX data has been transmitted.
 *
 * @return true if software buffer is empty and all bytes transmitted
 *         false if data is still pending in buffer or being transmitted
 *
 * @note This checks the SOFTWARE buffer state, not the UART hardware FIFO.
 *       Safe to call from any context.
 */
static bool uart_is_tx_ready(void)
{
    return tx_done;
}

/**
 * @brief Check if a complete line has been received.
 *
 * @return true if a line ending with CR/LF has been received
 *         false otherwise
 */
static bool uart_rx_available(void)
{
    return rx_done;
}

/**
 * @brief Flush UART state and recover from errors.
 *
 * Clears error flags, resets buffers, and re-arms reception.
 * Use this to recover from UART errors or to clear pending data.
 */
static void uart_flush(void)
{
    __HAL_UART_FLUSH_DRREGISTER(UARTxA);
    __HAL_UART_CLEAR_FEFLAG(UARTxA);
    __HAL_UART_CLEAR_NEFLAG(UARTxA);
    __HAL_UART_CLEAR_OREFLAG(UARTxA);

    tx_done = true;
    rx_done = false;
    rx_index = 0;

    // Re-arm reception
    HAL_UART_Receive_IT(UARTxA, &rx_byte, 1);
}

/* -------------------------------------------------------------------------- */
/*                         HAL Interrupt Callbacks                            */
/* -------------------------------------------------------------------------- */

/**
 * @brief DMA/IT transmission complete callback (CORRECTED VERSION).
 *
 * Called by HAL when a UART transmission completes (DMA or IT mode).
 *
 * CRITICAL FIXES:
 * 1. Atomically advances tail pointer and checks buffer state in ONE critical section
 * 2. Only releases DMA token (dma_tx_busy) if buffer is truly empty
 * 3. If data remains, keeps token and immediately restarts DMA
 * 4. Memory barriers ensure all writes are visible to other contexts
 *
 * This prevents the race condition where:
 * - Callback thinks buffer is empty and releases token
 * - Main thread adds data but sees stale dma_tx_busy=true
 * - Data gets stuck until next external trigger (e.g., pressing Enter)
 *
 * @param huart HAL UART handle
 */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance != UARTxA->Instance)
        return;

    // Ignore spurious callbacks
    if (!dma_tx_busy)
        return;

    /* ========== CRITICAL SECTION: Update tail and check buffer ========== */
    __disable_irq();
    __DMB(); // Memory barrier
    
    // 1. Advance tail by the amount just transmitted
    tx_ring.tail = (tx_ring.tail + last_dma_tx_len) % UART_TX_RING_SIZE;
    last_dma_tx_len = 0;
    
    // 2. Check buffer state ATOMICALLY
    bool buffer_empty = (tx_ring.head == tx_ring.tail);
    
    // 3. TOUJOURS libérer le jeton DMA après la fin d'un transfert DMA
    // Le prochain transfert doit être démarré par un appel explicite
    dma_tx_busy = false;
    
    if (buffer_empty) {
        // No more data: mark TX as done and release IRQs
        tx_done = true;
        __DMB(); 
        __enable_irq();
        return;
    }
    
    // 4. Data remains: DO NOT return yet, continue to restart DMA
    __DMB();
    __enable_irq();
    /* ==================================================================== */
    
    // 5. Restart DMA for next chunk.
    // Since dma_tx_busy is now false, uart_start_dma_from_ring() will try to acquire
    // the token and start the next transfer (which could be the wrap-around part).
    (void)uart_start_dma_from_ring();
    // Note: No need for fallback here, the transfer is guaranteed to start
    // or the state (dma_tx_busy=false) is maintained, allowing the next call to uart_send()
    // or HAL_UART_RxCpltCallback() to trigger it.
}

/** User-defined RX callback (called when a complete line is received). */
static rx_callback_t rx_cb = NULL;

/**
 * @brief Register a callback for complete line reception events.
 * @param cb Function to call when a line is received (or NULL to unregister)
 */
void uart_set_rx_callback(rx_callback_t cb)
{
    __disable_irq();
    rx_cb = cb;
    __enable_irq();
}

/**
 * @brief UART byte reception complete callback (CORRECTED VERSION).
 *
 * Called for each received byte. Handles:
 * - Normal characters: echo and store in buffer
 * - Enter (CR/LF): mark line complete, send prompt
 * - Backspace: delete last character with visual feedback
 *
 * CRITICAL FIX:
 * All echo output now goes through the TX ring buffer instead of blocking
 * HAL_UART_Transmit() calls. This prevents:
 * - Blocking in interrupt context
 * - Conflicts between IT and DMA transmission modes
 * - Delayed or stuck DMA transfers
 *
 * @param huart HAL UART handle
 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance != UARTxA->Instance)
        return;

    bool should_start_dma = false;

    /* ----- Case 1: ENTER key (Carriage Return or Line Feed) ----- */
    if (rx_byte == '\r' || rx_byte == '\n')
    {
        // Terminate string and mark line as complete
        rx_buffer[rx_index] = '\0';
        rx_done = true;

        // Send CRLF + prompt via ring buffer (non-blocking)
        const uint8_t crlf[4] = {'\r', '\n', '>', ' '};
        for (uint8_t i = 0; i < 4; i++) {
            tx_ring_push(crlf[i]);
        }
        
        should_start_dma = true;

        // Notify application that a line is ready
        if (rx_cb != NULL) {
            rx_cb();
        }
    }
    /* ----- Case 2: BACKSPACE (BS or DEL) ----- */
    else if (rx_byte == 0x08 || rx_byte == 0x7F)
    {
        if (rx_index > 0)
        {
            // Remove last character from buffer
            rx_index--;
            
            // Send backspace sequence: BS + space + BS (erase character visually)
            const uint8_t bs[3] = {0x08, ' ', 0x08};
            for (uint8_t i = 0; i < 3; i++) {
                tx_ring_push(bs[i]);
            }
            
            should_start_dma = true;
        }
    }
    /* ----- Case 3: Normal printable character ----- */
    else
    {
        if (rx_index < RX_BUFFER_SIZE - 1)
        {
            // Store character in line buffer
            rx_buffer[rx_index++] = rx_byte;
            
            // Echo character back to terminal
            tx_ring_push(rx_byte);
            
            should_start_dma = true;
        }
    }

    // Re-arm reception for next byte
    HAL_UART_Receive_IT(huart, &rx_byte, 1);

    // Start DMA if we added echo data and DMA is idle
    if (should_start_dma && !dma_tx_busy) {
        uart_start_dma_from_ring();
    }
}

/**
 * @brief UART error callback.
 *
 * Called by HAL when a UART error occurs (framing, overrun, noise, etc.).
 * Resets state to allow recovery.
 *
 * @param huart HAL UART handle
 */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == UARTxA->Instance)
    {
        // Reset transmission state
        tx_done = true;
        
        // Reset reception state
        rx_done = false;
        rx_index = 0;

        // Re-arm reception to recover
        HAL_UART_Receive_IT(UARTxA, &rx_byte, 1);
    }
}

/* -------------------------------------------------------------------------- */
/*                       Interface Instance Export                            */
/* -------------------------------------------------------------------------- */

/**
 * @brief UART communication interface instance.
 *
 * This structure provides function pointers for all communication operations.
 * Exposed globally as IComm_Debug for application use.
 */
const i_comm_t uart_peripheral = {
    .init           = uart_init,
    .send           = uart_send,
    .receive        = uart_receive,
    .tx_ready       = uart_is_tx_ready,
    .rx_available   = uart_rx_available,
    .flush          = uart_flush,
    .rx_callback    = uart_set_rx_callback
};

/** Global UART interface pointer (for debugging/logging). */
const i_comm_t* IComm_Debug = &uart_peripheral;