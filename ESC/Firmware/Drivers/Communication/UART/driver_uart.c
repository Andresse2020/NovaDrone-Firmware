/**
 * @file driver_uart.c
 * @brief UART driver implementation (HAL interrupt-based).
 *
 * Logic:
 * - UART reception is always armed for 1 byte using HAL_UART_Receive_IT().
 * - Each received byte is pushed into an internal buffer.
 * - When '\r' or '\n' is received, the buffer is considered complete
 *   and a flag rx_done is raised.
 * - The application can then call uart_receive() to copy the full line.
 */

#include "i_comm.h"
#include "bsp_utils.h"   // Utility macros/types
#include "usart.h"       // STM32 HAL UART handle
#include "driver_uart.h"
#include <string.h>

/* -------------------------------------------------------------------------- */
/*                         Internal configuration macros                      */
/* -------------------------------------------------------------------------- */
#define RX_BUFFER_SIZE   64  /**< Maximum size of one received line */
#define UART_TX_RING_SIZE 4096  // Taille ajustable

/* -------------------------------------------------------------------------- */
/*                   Internal state variables (interrupt mode)                */
/* -------------------------------------------------------------------------- */

/** Transmission complete flag (true = idle). */
static volatile bool tx_done = true;

/** Reception complete flag (true = one line is ready). */
static volatile bool rx_done = false;

/** Reception buffer (stores one line at a time). */
static uint8_t rx_buffer[RX_BUFFER_SIZE];

/** Current index inside rx_buffer. */
static volatile uint16_t rx_index = 0;

/** Temporary byte storage for interrupt-driven reception. */
static uint8_t rx_byte;

// Alias pointer to USART handle generated by CubeMX.
// This allows using 'UARTxA' instead of '&huart...' when calling HAL functions.
UART_HandleTypeDef* UARTxA = &huart2;


typedef struct {
    uint8_t buffer[UART_TX_RING_SIZE];
    volatile uint16_t head;
    volatile uint16_t tail;
} ring_buffer_t;

static ring_buffer_t tx_ring;  // Buffer TX circulaire


static inline bool tx_ring_is_empty(void) {
    return tx_ring.head == tx_ring.tail;
}

static inline bool tx_ring_is_full(void) {
    return ((tx_ring.head + 1) % UART_TX_RING_SIZE) == tx_ring.tail;
}

static bool tx_ring_push(uint8_t data) {
    if (tx_ring_is_full()) return false;
    tx_ring.buffer[tx_ring.head] = data;
    tx_ring.head = (tx_ring.head + 1) % UART_TX_RING_SIZE;
    return true;
}

static bool tx_ring_pop(uint8_t *data) {
    if (tx_ring_is_empty()) return false;
    *data = tx_ring.buffer[tx_ring.tail];
    tx_ring.tail = (tx_ring.tail + 1) % UART_TX_RING_SIZE;
    return true;
}



/* -------------------------------------------------------------------------- */
/*                        Forward declarations (static)                       */
/* -------------------------------------------------------------------------- */
static bool uart_init(void);
static comm_status_t uart_send(comm_node_t node, const uint8_t* data, uint16_t length);
static comm_status_t uart_receive(uint8_t* data, uint16_t length);
static bool uart_is_tx_ready(void);
static bool uart_rx_available(void);
static void uart_flush(void);

/* -------------------------------------------------------------------------- */
/*                    Implementation of interface functions                   */
/* -------------------------------------------------------------------------- */

/**
 * @brief Initialize UART peripheral.
 * @return true if successful, false otherwise.
 */
static bool uart_init(void)
{
    if (HAL_UART_Init(UARTxA) != HAL_OK)
        return false;

    tx_done = true;
    rx_done = false;
    rx_index = 0;

    /* Arm the first reception (1 byte) */
    HAL_UART_Receive_IT(UARTxA, &rx_byte, 1);

    // Erase the current prompt "> " on the terminal before sending new data
    const char bs_prompt[] = {0x08, ' ', 0x08, 0x08, ' ', 0x08};
    HAL_UART_Transmit(UARTxA, (uint8_t*)bs_prompt, sizeof(bs_prompt), HAL_MAX_DELAY);

    // ANSI escape code for blue text: \033[34m
    // Reset color: \033[0m
    const char *sys_start = "\033[34mStarting the System... \r\n\033[0m";
    HAL_UART_Transmit(UARTxA, (uint8_t*)sys_start, strlen(sys_start), HAL_MAX_DELAY);

    const char prompt[3] = "> ";
    HAL_UART_Transmit(UARTxA, (uint8_t*)prompt, sizeof(prompt)-1, HAL_MAX_DELAY);

    return true;
}

/**
 * @brief Start UART transmission (non-blocking).
 */
static comm_status_t uart_send(comm_node_t node, const uint8_t* data, uint16_t length)
{
    UNUSED(node);

    if (data == NULL || length == 0)
        return COMM_ERROR;

    // Push data into TX ring buffer
    for (uint16_t i = 0; i < length; i++) {
        if (!tx_ring_push(data[i]))
            return COMM_ERROR; // Buffer overflow
    }

    // If UART is idle, start transmission with the first byte
    if (tx_done) {
        uint8_t first;
        if (tx_ring_pop(&first)) {
            tx_done = false;
            if (HAL_UART_Transmit_IT(UARTxA, &first, 1) != HAL_OK) {
                tx_done = true;
                return COMM_ERROR;
            }
        }
    }

    return COMM_OK;
}


/**
 * @brief Copy the last received line into the user buffer.
 *
 * This function should be called only if rx_available() returns true.
 * After copying, the rx_done flag is cleared.
 */
static comm_status_t uart_receive(uint8_t* data, uint16_t length)
{
    if (data == NULL || length == 0)
        return COMM_ERROR;

    if (!rx_done)
        return COMM_BUSY; // No complete line available

    // Copy received line into user buffer
    uint16_t copy_len = (length < rx_index) ? length : rx_index;  // use actual received length
    memcpy(data, rx_buffer, copy_len);

    // Add null terminator only if used as string (optional)
    if (copy_len < length) {
        data[copy_len] = '\0';
    }

    // Reset reception state
    rx_done = false;
    rx_index = 0;

    return COMM_OK;
}


/**
 * @brief Check if TX buffer is idle.
 *
 * This function checks whether all data in the **software transmission buffer**
 * has been sent out via UART. 
 *
 * @return true  if the software buffer is empty and all bytes have been transmitted
 * @return false if there are still bytes pending in the software buffer
 *
 * Notes:
 * - 'tx_done' is set to true when the **software buffer has been completely emptied** 
 *   and the UART has transmitted all data.
 * - This allows higher-level code to know when it is safe to:
 *     - send new data
 *     - reset the system
 * - The function does not start or trigger transmission; it only reports status.
 */
static bool uart_is_tx_ready(void)
{
    return tx_done;
}



/**
 * @brief Check if a complete line has been received.
 */
static bool uart_rx_available(void)
{
    return rx_done;
}

/**
 * @brief Flush UART state and clear error flags.
 */
static void uart_flush(void)
{
    __HAL_UART_FLUSH_DRREGISTER(UARTxA);
    __HAL_UART_CLEAR_FEFLAG(UARTxA);
    __HAL_UART_CLEAR_NEFLAG(UARTxA);
    __HAL_UART_CLEAR_OREFLAG(UARTxA);

    tx_done = true;
    rx_done = false;
    rx_index = 0;

    /* Re-arm reception */
    HAL_UART_Receive_IT(UARTxA, &rx_byte, 1);
}

/* -------------------------------------------------------------------------- */
/*                  STM32 HAL callbacks (called on IRQ)                       */
/* -------------------------------------------------------------------------- */

/**
 * @brief Called by HAL when TX completes.
 */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == UARTxA->Instance)
    {
        uint8_t next;
        if (tx_ring_pop(&next)) {
            HAL_UART_Transmit_IT(UARTxA, &next, 1);
            
        } else {
            tx_done = true;
        }
    }
}

// User-defined RX callback
static rx_callback_t rx_cb = NULL;

/**
 * @brief Register a callback for RX events.
 */
void uart_set_rx_callback(rx_callback_t cb)
{
    __disable_irq();
    rx_cb = cb;
    __enable_irq();
}


/**
 * @brief UART receive complete callback (interrupt-driven).
 *
 * This function is called every time one byte is received on UART2.
 * It stores the received byte in a buffer, handles special keys
 * like ENTER and BACKSPACE, and echoes characters back to the terminal.
 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    // Make sure the callback is for USART2 (our active UART instance)
    if (huart->Instance != UARTxA->Instance)
        return;

    // ----- Case 1: ENTER key (CR or LF) -----
    if (rx_byte == '\r' || rx_byte == '\n')
    {
        // Terminate the current string
        rx_buffer[rx_index] = 0;
        rx_done = true;  // Notify application that a line is ready

        // Send CRLF back to terminal (blocking to avoid HAL state issues)
        uint8_t crlf[4] = {'\r','\n', '>', ' '};
        HAL_UART_Transmit(huart, crlf, 4, HAL_MAX_DELAY);

        if ( rx_cb != NULL)
        {
            rx_cb();  // Notify higher layer that a frame is ready
        }
    }
    // ----- Case 2: BACKSPACE (0x08 or 0x7F) -----
    else if (rx_byte == 0x08 || rx_byte == 0x7F)
    {
        if (rx_index > 0)
        {
            // Remove last character from buffer
            rx_index--;

            // Echo backspace sequence: move cursor left, erase char, move left again
            uint8_t bs[3] = {0x08, ' ', '\b'};
            HAL_UART_Transmit(huart, bs, 3, HAL_MAX_DELAY);
        }
    }
    // ----- Case 3: Normal character -----
    else
    {
        if (rx_index < RX_BUFFER_SIZE - 1)
        {
            // Store character into buffer
            rx_buffer[rx_index++] = rx_byte;

            // Echo character back to terminal
            HAL_UART_Transmit_IT(huart, &rx_byte, 1);
        }
    }

    // Always re-arm UART reception for the next byte
    HAL_UART_Receive_IT(huart, &rx_byte, 1);
}


/**
 * @brief Called by HAL on UART error.
 *
 * Resets TX/RX state to allow recovery.
 */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == UARTxA->Instance)
    {
        tx_done = true;
        rx_done = false;
        rx_index = 0;

        /* Re-arm reception to recover */
        HAL_UART_Receive_IT(UARTxA, &rx_byte, 1);
    }
}


/* -------------------------------------------------------------------------- */
/*                       Interface instance definition                        */
/* -------------------------------------------------------------------------- */

/**
 * @brief UART interface instance (bound to USART2).
 *
 * This object is exposed globally as `IComm` and provides
 * function pointers for communication.
 */
const i_comm_t uart_peripheral = {
    .init           =   uart_init,
    .send           =   uart_send,
    .receive        =   uart_receive,
    .tx_ready       =   uart_is_tx_ready,
    .rx_available   =   uart_rx_available,
    .flush          =   uart_flush,
    .rx_callback    =   uart_set_rx_callback
};

const i_comm_t* IComm_Debug = &uart_peripheral; /**< Global communication interface instance for debugging */
