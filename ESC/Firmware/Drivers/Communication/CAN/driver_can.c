/* driver_can.c
 *
 * Autonomous FDCAN2 driver:
 * - accepts messages of any length up to CAN_TX_BUFFER_SIZE
 * - splits into 8-byte CAN frames
 * - sends first frame immediately
 * - subsequent frames are sent automatically from HAL callbacks
 *
 * Comments in English
 */

#include "driver_can.h"
#include "fdcan.h"      // CubeMX-generated FDCAN handle & HAL prototypes
#include "bsp_utils.h"
#include <string.h>
#include <stdint.h>
#include <stdbool.h>


// Alias pointer to FDCAN handle generated by CubeMX.
// This allows using 'CANxA' instead of '&hfdcan...' when calling HAL FDCAN functions.
FDCAN_HandleTypeDef* CANxA = &hfdcan2;


/* --------------------------------------------------------------------------
 * CAN node → CAN ID mapping
 * -------------------------------------------------------------------------- */
static uint32_t can_id_from_node(comm_node_t node)
{
    switch(node)
    {
        case DISPLAY: return 0x123;
        case NONE:    return 0x000;
        default:      return 0; // invalid node
    }
}

/* --------------------------------------------------------------------------
 * Internal tx buffer
 * Adjust CAN_TX_BUFFER_SIZE to your needs (must be >= largest message)
 * -------------------------------------------------------------------------- */
#define CAN_TX_BUFFER_SIZE 256U  // increase if you need bigger messages
static uint8_t tx_buffer[CAN_TX_BUFFER_SIZE];
static uint16_t tx_length = 0;       // total length of current message
static uint16_t tx_index  = 0;       // next byte to send
static comm_node_t tx_node  = NONE;
static volatile bool sending_in_progress = false;

/* Forward */
static comm_status_t send_next_frame(void);

/* --------------------------------------------------------------------------
 * Initialize CAN2 (called by application via IComm->init)
 * -------------------------------------------------------------------------- */
static bool can_init(void)
{
    if (HAL_FDCAN_Start(CANxA) != HAL_OK)
        return false;

    /* Activate notifications:
     * - TX_COMPLETE for buffer completion callbacks
     * - TX_FIFO_EMPTY to get notified when FIFO can accept more frames (required in FIFO queue mode)
     *
     * Note: The last parameter is not used by Cube HAL on some versions (keep 0).
     */
    HAL_FDCAN_ActivateNotification(CANxA, FDCAN_IT_TX_COMPLETE | FDCAN_IT_TX_FIFO_EMPTY | FDCAN_IT_RX_FIFO0_NEW_MESSAGE, 0);

    return true;
}

/* --------------------------------------------------------------------------
 * Internal: send one 8-byte frame (non-blocking)
 * Returns COMM_OK when frame queued, COMM_BUSY when FIFO full,
 * COMM_OK+no-data if nothing to send
 * -------------------------------------------------------------------------- */
static comm_status_t send_next_frame(void)
{
    /* nothing to send */
    if (tx_index >= tx_length)
    {
        sending_in_progress = false;
        return COMM_OK;
    }

    /* check FIFO free level */
    if (HAL_FDCAN_GetTxFifoFreeLevel(CANxA) == 0)
    {
        /* FIFO full: try later */
        return COMM_BUSY;
    }

    /* prepare header */
    FDCAN_TxHeaderTypeDef tx_header;
    memset(&tx_header, 0, sizeof(tx_header));
    tx_header.Identifier         = can_id_from_node(tx_node);
    tx_header.IdType             = FDCAN_STANDARD_ID;
    tx_header.TxFrameType        = FDCAN_DATA_FRAME;

    uint8_t chunk = (uint8_t)((tx_length - tx_index) > 8 ? 8 : (tx_length - tx_index));
    tx_header.DataLength         = chunk;
    tx_header.ErrorStateIndicator= FDCAN_ESI_ACTIVE;
    tx_header.BitRateSwitch      = FDCAN_BRS_OFF;
    tx_header.FDFormat           = FDCAN_CLASSIC_CAN;
    tx_header.TxEventFifoControl = FDCAN_NO_TX_EVENTS;
    tx_header.MessageMarker      = 0;

    /* add to FIFO queue */
    if (HAL_FDCAN_AddMessageToTxFifoQ(CANxA, &tx_header, &tx_buffer[tx_index]) == HAL_OK)
    {
        tx_index += chunk;
        sending_in_progress = true;
        return COMM_OK;
    }
    else
    {
        /* HAL returns error if FIFO couldn't accept frame */
        return COMM_BUSY;
    }
}

/* --------------------------------------------------------------------------
 * Application-facing send()
 * Copies message into internal buffer and sends first chunk.
 * Non-blocking: returns COMM_BUSY if driver is busy.
 * -------------------------------------------------------------------------- */
static comm_status_t can_send(comm_node_t node, const uint8_t* data, uint16_t length)
{
    if (data == NULL || length == 0 || length > CAN_TX_BUFFER_SIZE)
        return COMM_ERROR;

    /* reject new message while previous still being transmitted */
    if (sending_in_progress)
        return COMM_BUSY;

    /* validate node -> id */
    uint32_t id = can_id_from_node(node);
    if (id == 0)
        return COMM_ERROR;

    /* copy */
    memcpy(tx_buffer, data, length);
    tx_length   = length;
    tx_index    = 0;
    tx_node = node;
    sending_in_progress = false;

    /* try to send the first frame immediately */
    return send_next_frame();
}

/* --------------------------------------------------------------------------
 * Application-facing is_tx_ready()
 * returns true only when previous message fully transmitted
 * -------------------------------------------------------------------------- */
static bool can_tx_ready(void)
{
    return !sending_in_progress;
}

/* --------------------------------------------------------------------------
 * HAL Callbacks
 * We implement both possible callbacks used by different HAL versions/modes.
 * Both call send_next_frame() so the sequence continues automatically.
 * -------------------------------------------------------------------------- */

/* Called when a single TX buffer is completed (some HAL versions). */
void HAL_FDCAN_TxBufferCompleteCallback(FDCAN_HandleTypeDef *hfdcan, uint32_t BufferIdx)
{
    UNUSED(BufferIdx);

    if (hfdcan != CANxA) return;

    /* Try send next frame(s). Note: send_next_frame will stop if FIFO full. */
    (void) send_next_frame();
}

/* Called when TX FIFO becomes empty / available (some HAL versions). */
void HAL_FDCAN_TxFifoEmptyCallback(FDCAN_HandleTypeDef *hfdcan)
{
    if (hfdcan != CANxA) return;

    (void) send_next_frame();
}

/* --------------------------------------------------------------------------
 * RX handling
 * -------------------------------------------------------------------------- */

/* Internal RX buffer */
#define CAN_RX_BUFFER_SIZE 8U 
static uint8_t rx_buffer[CAN_RX_BUFFER_SIZE];
static uint16_t rx_length = 0;
static volatile bool rx_ready = false;

/* Application-facing receive() */
static comm_status_t can_receive(uint8_t* data, uint16_t length)
{

    if (!rx_ready)
        return COMM_BUSY;

    if (length < rx_length)
        return COMM_ERROR; /* buffer too small */

    memcpy(data, rx_buffer, rx_length);
    rx_ready = false;
    return COMM_OK;
}

/* RX Callback from FIFO0 */
void HAL_FDCAN_RxFifo0Callback(FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo0ITs)
{
    if (hfdcan != CANxA) return;

    if ((RxFifo0ITs & FDCAN_IT_RX_FIFO0_NEW_MESSAGE) != 0)
    {
        FDCAN_RxHeaderTypeDef rxHeader;
        if (HAL_FDCAN_GetRxMessage(hfdcan, FDCAN_RX_FIFO0, &rxHeader, rx_buffer) == HAL_OK)
        {
            // DLC → nombre d’octets réels
            switch(rxHeader.DataLength)
            {
                case FDCAN_DLC_BYTES_0:  rx_length = 0;  break;
                case FDCAN_DLC_BYTES_1:  rx_length = 1;  break;
                case FDCAN_DLC_BYTES_2:  rx_length = 2;  break;
                case FDCAN_DLC_BYTES_3:  rx_length = 3;  break;
                case FDCAN_DLC_BYTES_4:  rx_length = 4;  break;
                case FDCAN_DLC_BYTES_5:  rx_length = 5;  break;
                case FDCAN_DLC_BYTES_6:  rx_length = 6;  break;
                case FDCAN_DLC_BYTES_7:  rx_length = 7;  break;
                case FDCAN_DLC_BYTES_8:  rx_length = 8;  break;
                case FDCAN_DLC_BYTES_12: rx_length = 12; break;
                case FDCAN_DLC_BYTES_16: rx_length = 16; break;
                case FDCAN_DLC_BYTES_20: rx_length = 20; break;
                case FDCAN_DLC_BYTES_24: rx_length = 24; break;
                case FDCAN_DLC_BYTES_32: rx_length = 32; break;
                case FDCAN_DLC_BYTES_48: rx_length = 48; break;
                case FDCAN_DLC_BYTES_64: rx_length = 64; break;
                default: rx_length = 0; break; // valeur par défaut sécurisée
            }

            rx_ready = true;
        }
    }
}



/* --------------------------------------------------------------------------
 * Additional IComm helpers
 * -------------------------------------------------------------------------- */
static bool can_rx_available(void)
{
    return rx_ready;
}


static void can_flush(void)
{
    sending_in_progress = false;
    tx_length = 0;
    tx_index = 0;
    rx_ready = false;
    rx_length = 0;
}

/* --------------------------------------------------------------------------
 * Exported IComm instance
 * -------------------------------------------------------------------------- */
const i_comm_t CAN2_peripheral = {
    .init           =  can_init,
    .send           =  can_send,
    .receive        =  can_receive,
    .tx_ready       =  can_tx_ready,
    .rx_available   =  can_rx_available,
    .flush          =  can_flush,
};


const i_comm_t* IComm_Release = &CAN2_peripheral;