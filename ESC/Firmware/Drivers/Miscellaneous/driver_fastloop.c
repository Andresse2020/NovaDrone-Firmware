/**
 * @file driver_fastloop.c
 * @brief Hardware-level implementation of the Fast Loop interface (i_fastloop_t) using TIM3.
 *
 * This driver configures TIM3 to generate a periodic interrupt at the Fast Loop
 * frequency (typically 24 kHz). It directly implements the i_fastloop_t interface
 * and exposes the global instance `IFastLoop` used by the Control Layer.
 *
 * The driver is responsible only for:
 *  - Configuring and starting TIM3 update interrupts
 *  - Executing the registered callback once per control period
 *
 * Target MCU: STM32G473CCTx
 */

#include "i_fastloop.h"
#include "timers_callbacks.h"
#include "bsp_utils.h"
#include "tim.h"                // TIM3 handle generated by CubeMX

/* ========================================================================== */
/* === Private Static Variables ============================================ */
/* ========================================================================== */

/** 
 * @brief Pointer to the function executed at each Fast Loop tick.
 *        This callback is registered by the Control Layer through IFastLoop->register_callback().
 */
static fastloop_callback_t s_registered_cb = NULL;

/**
 * @brief Nominal Fast Loop frequency in Hertz.
 *        This value should match the TIM3 configuration (ARR, Prescaler).
 *        Example: 24 kHz → period = 41.67 µs.
 */
static uint32_t s_fastloop_freq_hz = 24000U;

/* ========================================================================== */
/* === Local Helper Functions ============================================== */
/* ========================================================================== */

/**
 * @brief Local helper called on each TIM3 interrupt.
 *        Executes the control-layer callback if registered.
 *        This function should execute in less than one control period.
 */
static void Driver_FastLoop_OnTick(void)
{
    if (s_registered_cb != NULL)
    {
        /* Execute the control algorithm callback (e.g., Motor_FastLoop) */
        s_registered_cb();
    }
}

/* ========================================================================== */
/* === i_fastloop_t Interface Implementation =============================== */
/* ========================================================================== */

/**
 * @brief Initialize TIM3 for Fast Loop operation.
 *
 * This function ensures that TIM3 is properly reset and ready for operation.
 * The hardware configuration (prescaler, ARR, interrupt enable) must be
 * done in CubeMX.
 *
 * @retval true  Initialization succeeded.
 * @retval false Initialization failed (e.g., invalid ARR).
 */
static bool drv_fastloop_init(void)
{
    /* Ensure timer callbacks dispatcher is initialized */
    if (!Timer_Callbacks_IsInitialized())
    {
        if (!Timer_callbacks_Init())
        {
            return false;
        }
    }
    /* Clear any previously registered callback */
    s_registered_cb = NULL;

    /* Ensure TIM3 is stopped and counter is reset */
    __HAL_TIM_DISABLE(&htim3);
    __HAL_TIM_SET_COUNTER(&htim3, 0);

    /* Basic sanity check: ensure ARR value is valid */
    if (__HAL_TIM_GET_AUTORELOAD(&htim3) == 0)
        return false;

    return true;
}

/**
 * @brief Register a callback function to be executed each Fast Loop cycle.
 *
 * @param cb Pointer to the callback function. 
 *           Pass NULL to disable the callback execution.
 */
static void drv_fastloop_register_callback(fastloop_callback_t cb)
{
    s_registered_cb = cb;
}

/**
 * @brief Start periodic Fast Loop execution.
 *
 * This function enables TIM3 update interrupts. Once started, the registered
 * callback (if any) will be executed at each timer overflow (e.g., 24 kHz).
 */
static void drv_fastloop_start(void)
{
    /* Clear any pending update flag before starting */
    __HAL_TIM_CLEAR_FLAG(&htim3, TIM_FLAG_UPDATE);

    /* Start TIM3 in interrupt mode */
    HAL_TIM_Base_Start_IT(&htim3);
}

/**
 * @brief Stop periodic Fast Loop execution.
 *
 * Disables TIM3 update interrupts. The timer configuration remains intact
 * and can be restarted with drv_fastloop_start().
 */
static void drv_fastloop_stop(void)
{
    HAL_TIM_Base_Stop_IT(&htim3);
}

/**
 * @brief Get the configured Fast Loop frequency in Hertz.
 *
 * @return Nominal frequency in Hz (e.g., 24000 for 24 kHz).
 */
static uint32_t drv_fastloop_get_frequency_hz(void)
{
    return s_fastloop_freq_hz;
}

/* ========================================================================== */
/* === HAL Interrupt Binding =============================================== */
/* ========================================================================== */

/**
 * @brief HAL callback executed when a TIM update event occurs.
 *
 * This function is automatically called by the HAL interrupt handler.
 * It identifies the timer source and calls the Fast Loop tick handler.
 *
 * @param htim Pointer to the timer handle structure.
 */
void Driver_FastLoop_OnTimerElapsed(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM3)
    {
        Driver_FastLoop_OnTick();
    }
}

/* ========================================================================== */
/* === Global Interface Instance =========================================== */
/* ========================================================================== */

/**
 * @brief Static instance implementing the i_fastloop_t interface.
 */
static i_fastloop_t s_driver_fastloop_iface = {
    .init              = drv_fastloop_init,
    .register_callback = drv_fastloop_register_callback,
    .start             = drv_fastloop_start,
    .stop              = drv_fastloop_stop,
    .get_frequency_hz  = drv_fastloop_get_frequency_hz,
};

/**
 * @brief Global Fast Loop interface instance.
 * 
 * This symbol is exposed to the entire firmware as the active Fast Loop provider.
 * The Control Layer calls IFastLoop->register_callback(), IFastLoop->start(), etc.
 */
i_fastloop_t* IFastLoop = &s_driver_fastloop_iface;
