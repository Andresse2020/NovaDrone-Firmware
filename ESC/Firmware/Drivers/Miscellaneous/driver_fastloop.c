/**
 * @file driver_fastloop.c
 * @brief Hardware-level implementation of the Fast Loop interface (i_periodic_loop_t) using TIM3.
 *
 * This module implements the high-frequency control loop trigger (e.g., 24 kHz)
 * using a hardware timer configured to generate periodic interrupts.
 * It directly implements the generic i_periodic_loop_t interface.
 *
 * Responsibilities:
 *   - Configure and manage the timer resource (TIM3 by default)
 *   - Call the registered control-layer callback every control period
 *   - Expose a portable, hardware-agnostic interface to upper layers
 *
 * Usage example:
 *   IFastLoop->init();
 *   IFastLoop->register_callback(Motor_FastLoop);
 *   IFastLoop->start();
 *
 * Target MCU: STM32G473CCTx
 */

#include "i_periodic_loop.h"
#include "timers_callbacks.h"
#include "bsp_utils.h"
#include "tim.h"   // Auto-generated by STM32CubeMX

/* ========================================================================== */
/* === Configuration Macros ================================================ */
/* ========================================================================== */

/**
 * @brief Define which hardware timer is used for the Fast Loop.
 *
 * These definitions isolate all hardware dependencies in one place.
 * To migrate the Fast Loop to another timer (e.g., TIM1, TIM2), simply
 * update these two macros — no other code changes required.
 */
#define FASTLOOP_TIMER_HANDLE     (&htim3)
#define FASTLOOP_TIMER_INSTANCE   TIM3

/* ========================================================================== */
/* === Private Static Variables ============================================ */
/* ========================================================================== */

/**
 * @brief Pointer to the callback function executed at each Fast Loop tick.
 *
 * This function is typically the main high-frequency control routine,
 * such as current or six-step commutation control. It is registered
 * by the Control Layer via IFastLoop->register_callback().
 */
static periodic_callback_t s_registered_cb = NULL;

/**
 * @brief Nominal Fast Loop frequency in Hertz.
 *
 * Must match the hardware timer configuration:
 *   Freq = TIM_CLK / ((PSC + 1) * (ARR + 1))
 * Example:
 *   TIM_CLK = 150 MHz, PSC = 0, ARR = 6249 → Freq = 24 000 Hz
 */
static uint32_t s_fastloop_freq_hz = 24000U;

/* ========================================================================== */
/* === Local Helper Functions ============================================== */
/* ========================================================================== */

/**
 * @brief Execute one Fast Loop tick.
 *
 * This function is called at each timer overflow interrupt.
 * It invokes the registered callback if one is available.
 *
 * @note This function executes in interrupt context (ISR).
 *       It must complete within one control period to avoid jitter
 *       or overlapping interrupts.
 */
static void Driver_FastLoop_OnTick(void)
{
    if (s_registered_cb != NULL)
    {
        s_registered_cb();  // Run control-layer function (e.g., FOC loop)
    }
}

/* ========================================================================== */
/* === i_periodic_loop_t Implementation ==================================== */
/* ========================================================================== */

/**
 * @brief Initialize the Fast Loop driver.
 *
 * This prepares the timer but does not start it. All timer configuration
 * (prescaler, ARR, clock source) should be done via CubeMX.
 *
 * @retval true   Initialization successful.
 * @retval false  Timer configuration invalid (e.g., ARR = 0).
 */
static bool drv_fastloop_init(void)
{
    /* Ensure the timer callback system is initialized */
    if (!Timer_Callbacks_IsInitialized())
    {
        if (!Timer_callbacks_Init())
        {
            return false;
        }
    }

    /* Clear any previously registered callback */
    s_registered_cb = NULL;

    /* Ensure timer is stopped and counter reset */
    __HAL_TIM_DISABLE(FASTLOOP_TIMER_HANDLE);
    __HAL_TIM_SET_COUNTER(FASTLOOP_TIMER_HANDLE, 0);

    /* Sanity check: ensure ARR configured in CubeMX */
    if (__HAL_TIM_GET_AUTORELOAD(FASTLOOP_TIMER_HANDLE) == 0)
        return false;

    return true;
}

/**
 * @brief Register the function executed at each Fast Loop cycle.
 *
 * @param cb Pointer to user-defined callback function.
 *           Pass NULL to disable callback execution.
 */
static void drv_fastloop_register_callback(periodic_callback_t cb)
{
    s_registered_cb = cb;
}

/**
 * @brief Start the periodic Fast Loop execution.
 *
 * This enables timer interrupts. Once started, the registered callback
 * will be invoked at each timer overflow (e.g., every 41.67 µs at 24 kHz).
 */
static void drv_fastloop_start(void)
{
    /* Clear any pending update flag before enabling interrupts */
    __HAL_TIM_CLEAR_FLAG(FASTLOOP_TIMER_HANDLE, TIM_FLAG_UPDATE);

    /* Start timer in interrupt mode */
    HAL_TIM_Base_Start_IT(FASTLOOP_TIMER_HANDLE);
}

/**
 * @brief Stop the periodic Fast Loop execution.
 *
 * Disables the timer update interrupt. The configuration (ARR/PSC)
 * remains intact and can be restarted by calling start().
 */
static void drv_fastloop_stop(void)
{
    HAL_TIM_Base_Stop_IT(FASTLOOP_TIMER_HANDLE);
}

/**
 * @brief Return the configured Fast Loop frequency in Hz.
 *
 * @return Nominal Fast Loop frequency (e.g., 24000 Hz).
 */
static uint32_t drv_fastloop_get_frequency_hz(void)
{
    return s_fastloop_freq_hz;
}

/**
 * @brief Manually trigger a single Fast Loop cycle.
 *
 * This is useful for unit testing or system calibration routines
 * without enabling continuous operation.
 */
static void drv_fastloop_trigger_once(void)
{
    Driver_FastLoop_OnTick();
}

/* ========================================================================== */
/* === HAL Interrupt Binding =============================================== */
/* ========================================================================== */

/**
 * @brief HAL callback called at every timer update event.
 *
 * This function must be called from the generic HAL_TIM_PeriodElapsedCallback()
 * in stm32xx_it.c to dispatch the interrupt to this driver.
 *
 * @param htim Pointer to the timer handle structure.
 */
void Driver_FastLoop_OnTimerElapsed(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == FASTLOOP_TIMER_INSTANCE)
    {
        Driver_FastLoop_OnTick();
    }
}

/* ========================================================================== */
/* === Global Interface Instance =========================================== */
/* ========================================================================== */

/**
 * @brief Static instance implementing the i_periodic_loop_t interface.
 *
 * All functions are mapped to the driver implementations defined above.
 */
static i_periodic_loop_t s_driver_fastloop_iface = {
    .init              = drv_fastloop_init,
    .register_callback = drv_fastloop_register_callback,
    .start             = drv_fastloop_start,
    .stop              = drv_fastloop_stop,
    .get_frequency_hz  = drv_fastloop_get_frequency_hz,
    .trigger_once      = drv_fastloop_trigger_once,
};

/**
 * @brief Global Fast Loop interface instance.
 *
 * This pointer is exposed globally and represents the
 * active Fast Loop provider in the system.
 *
 * Example usage from the Control Layer:
 *   IFastLoop->register_callback(Control_FastLoop);
 *   IFastLoop->start();
 */
i_periodic_loop_t* IFastLoop = &s_driver_fastloop_iface;
